<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>강아지 스네이크 (부드러운 이동 + 키힌트)</title>
<style>
  :root{
    --bg:#0b1220;
    --tileA:#223049;      /* 체스판 색 A (초기값) */
    --tileB:#1a2438;      /* 체스판 색 B (초기값) */
    --dog-body:#7dd3fc;   /* 몸통 기본 */
    --dog-head:#38bdf8;   /* 머리 하이라이트 */
    --dog-outline:#0e7490;
    --tongue:#ef4444;
    --meat:#d97706;       /* 고기 */
    --meat-fat:#fff7ed;   /* 지방/뼈 */
    --ui:#e5e7eb;
    --panel:#0f172a;
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; background:var(--bg);
    color:var(--ui); font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    display:grid; gap:0;
    grid-template-columns: 1fr min(320px, 35vw);
  }
  #stage-wrap{display:flex; flex-direction:column; align-items:center; justify-content:center; padding:14px;}
  h1{margin:0 0 .5rem; font-size:1.1rem; font-weight:700; opacity:.9}
  canvas{background:black; border:2px solid #334155; border-radius:12px; image-rendering:pixelated}
  .hud{display:flex; gap:1.2rem; align-items:flex-start; justify-content:center; flex-wrap:wrap; margin-top:.6rem}
  .btnwrap{display:flex; flex-direction:column; align-items:center; gap:.25rem}
  .btn{background:#334155; color:white; border:none; border-radius:10px; padding:.55rem 1rem; cursor:pointer; font-weight:700; min-width:96px; text-align:center}
  .btn:active{transform:translateY(1px)}
  .hint{font-size:.8rem; opacity:.75}
  .muted{opacity:.75; font-size:.92rem; align-self:center}
  .pad{display:grid; grid-template-columns:repeat(3,56px); grid-template-rows:repeat(3,56px); gap:.4rem; margin:.4rem 0 0}
  .pad button{background:#1f2937; border:2px solid #334155; color:#cbd5e1; font-size:1rem; border-radius:10px}
  @media(min-width:720px){ .pad{display:none} }

  /* 사이드 패널 */
  aside{
    background:var(--panel); border-left:1px solid #223; padding:16px 14px;
    display:flex; flex-direction:column; gap:14px;
  }
  .panel-group{background:#0b1324; border:1px solid #213; border-radius:10px; padding:12px}
  .panel-group h3{margin:0 0 .5rem; font-size:.98rem}
  .row{display:flex; align-items:center; justify-content:space-between; gap:10px; margin:.4rem 0}
  .row label{font-size:.92rem; opacity:.9}
  select{width:160px; padding:.4rem .5rem; background:#111a2d; border:1px solid #233; color:#e5e7eb; border-radius:8px}
  .tip{font-size:.88rem; opacity:.75; line-height:1.4}
</style>
</head>
<body>
  <div id="stage-wrap">
    <h1>강아지 스네이크 🐶🍖</h1>
    <canvas id="game" width="420" height="420" aria-label="게임 캔버스"></canvas>

    <div class="hud">
      <div>점수: <strong id="score">0</strong></div>
      <div>최고: <strong id="best">0</strong></div>

      <div class="btnwrap">
        <button class="btn" id="toggle">시작</button>
        <div class="hint">(Space)</div>
      </div>

      <div class="btnwrap">
        <button class="btn" id="restart">다시하기</button>
        <div class="hint">(R)</div>
      </div>

      <span class="muted">방향키 / WASD</span>
    </div>

    <!-- 모바일 방향패드 -->
    <div class="pad" aria-hidden="true">
      <span></span><button data-d="up">▲</button><span></span>
      <button data-d="left">◀</button><span></span><button data-d="right">▶</button>
      <span></span><button data-d="down">▼</button><span></span>
    </div>
  </div>

  <aside>
    <div class="panel-group">
      <h3>체스판 색상 (9색 제한)</h3>
      <div class="row">
        <label for="selA">타일 A</label>
        <select id="selA"></select>
      </div>
      <div class="row">
        <label for="selB">타일 B</label>
        <select id="selB"></select>
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn" id="resetColors">초기화</button>
      </div>
      <p class="tip">흰/검처럼 밝기 차가 큰 조합이 가장 잘 보입니다.</p>
    </div>
    <div class="panel-group">
      <h3>도움말</h3>
      <p class="tip">스페이스로 시작/일시정지, R키로 다시하기. 벽에 부딪히면 게임오버. 최고 점수는 브라우저에 저장돼요.</p>
    </div>
  </aside>

<script>
(() => {
  // ===== 기본 보드/렌더 설정 =====
  const cell = 20, cols = 20, rows = 20;
  const w = cols * cell, h = rows * cell;
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d', { alpha:false });
  cvs.width = w; cvs.height = h;

  // HUD
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const toggleBtn = document.getElementById('toggle');
  const restartBtn= document.getElementById('restart');

  const bestKey = 'dog-snake-best';
  let best = Number(localStorage.getItem(bestKey) || 0);
  bestEl.textContent = best;

  // ===== 사운드 =====
  const AC = window.AudioContext || window.webkitAudioContext;
  let actx = null; function audio(){ if(!actx) actx = new AC(); }
  function beep({f=600,d=0.07,type='square',v=0.2}) {
    audio(); const t=actx.currentTime, o=actx.createOscillator(), g=actx.createGain();
    o.type=type; o.frequency.setValueAtTime(f,t);
    g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001,t+d);
    o.connect(g).connect(actx.destination); o.start(t); o.stop(t+d);
  }
  const sTurn = ()=>beep({f:520,d:0.05,type:'triangle',v:0.15});
  const sEat  = ()=>{beep({f:420,d:0.07,type:'sine',v:0.24}); setTimeout(()=>beep({f:640,d:0.07,type:'sine',v:0.24}),60);};

  // ===== 상태 =====
  let snake, dir, pendingDir, food, score, speed, running, lastTime, acc;
  let tongueTimer = 0;

  // 보간용 스냅샷(이전 스텝 상태)
  let prevSnake = null;
  let prevDir = {x:1,y:0};

  function init(){
    snake=[{x:10,y:10}];
    dir={x:1,y:0}; pendingDir=dir; prevDir=dir;
    score=0; speed=8; running=false; lastTime=0; acc=0; tongueTimer=0;
    food=spawnFood(); scoreEl.textContent=score;
    prevSnake = cloneSnake(snake);
    draw(0); // 초기 화면
  }
  function spawnFood(){
    while(true){
      const p={x:Math.floor(Math.random()*cols), y:Math.floor(Math.random()*rows)};
      if(!snake.some(s=>s.x===p.x&&s.y===p.y)) return p;
    }
  }
  function cloneSnake(arr){ return arr.map(p=>({x:p.x, y:p.y})); }

  // ===== 입력 =====
  const key2dir={ArrowUp:{x:0,y:-1},ArrowDown:{x:0,y:1},ArrowLeft:{x:-1,y:0},ArrowRight:{x:1,y:0},
                 w:{x:0,y:-1},s:{x:0,y:1},a:{x:-1,y:0},d:{x:1,y:0}};
  addEventListener('keydown',e=>{
    const k=e.key.toLowerCase();
    if(k in key2dir){
      const nd=key2dir[k];
      if(snake.length>1 && (nd.x===-dir.x && nd.y===-dir.y)) return;
      if(nd.x!==dir.x || nd.y!==dir.y) sTurn();
      pendingDir=nd; e.preventDefault();
    } else if(k===' '){ toggle(); e.preventDefault(); }
      else if(k==='r'){ restartBtn.click(); e.preventDefault(); }
  });
  document.querySelectorAll('.pad [data-d]').forEach(b=>{
    b.addEventListener('click',()=>{
      const map={up:{x:0,y:-1},down:{x:0,y:1},left:{x:-1,y:0},right:{x:1,y:0}};
      const nd=map[b.dataset.d];
      if(snake.length>1 && (nd.x===-dir.x && nd.y===-dir.y)) return;
      if(nd.x!==dir.x || nd.y!==dir.y) sTurn();
      pendingDir=nd;
    });
  });

  // ===== 루프 =====
  function loop(ts){
    if(!running) return;
    const dt=(ts-lastTime)/1000; lastTime=ts; acc+=dt; tongueTimer+=dt;
    const step=1/speed;

    // 1) 필요한 만큼 스텝 업데이트 (벽/몸 충돌, 먹이 판정은 격자 단위)
    while(acc>=step){
      prevSnake = cloneSnake(snake);
      prevDir = {x:dir.x, y:dir.y};
      update();               // 한 스텝 진행
      acc -= step;
    }

    // 2) 보간 비율 t = 지난 스텝 이후 경과시간 / 스텝시간 (0~1)
    const t = (acc < step) ? (acc/step) : 0;
    draw(t);

    requestAnimationFrame(loop);
  }

  function update(){
    dir=pendingDir;
    // 벽 충돌 모드
    const nx = snake[0].x + dir.x;
    const ny = snake[0].y + dir.y;
    if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return gameOver();
    const head={x:nx, y:ny};

    if(snake.some((s,i)=>i>0 && s.x===head.x&&s.y===head.y)) return gameOver();

    snake.unshift(head);
    if(head.x===food.x && head.y===food.y){
      score++; scoreEl.textContent=score; speed=Math.min(16,speed+0.3); sEat(); food=spawnFood();
    } else snake.pop();
  }

  // ===== 그리기 (보간 렌더) =====
  function draw(t=0){
    drawBoard();            // 체크무늬
    drawMeat(food.x, food.y);

    // 보간된 위치 계산: prevSnake -> snake 사이를 t만큼
    const segCount = snake.length;
    for(let i=segCount-1;i>=0;i--){
      const cur = snake[i];
      const prv = (prevSnake && prevSnake[i]) ? prevSnake[i] : cur;
      const ix = lerp(prv.x, cur.x, t) * cell;
      const iy = lerp(prv.y, cur.y, t) * cell;

      if(i===0){
        // 머리는 진행 방향을 현재 dir 기준으로, 위치는 보간값
        drawDogHeadAt(ix, iy, dir);
      }else{
        drawDogBodyAt(ix, iy);
      }
    }
  }

  function lerp(a,b,t){ return a + (b-a)*t; }

  // 체스판(체크무늬) 타일 그리기
  function drawBoard(){
    const A = getVar('--tileA') || '#223049';
    const B = getVar('--tileB') || '#1a2438';
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        ctx.fillStyle = ((x+y)%2===0) ? A : B;
        ctx.fillRect(x*cell, y*cell, cell, cell);
      }
    }
  }

  // 먹이: 드럼스틱 고기
  function drawMeat(cx, cy){
    const px=cx*cell, py=cy*cell, s=cell;
    const cX=px+s/2, cY=py+s/2;

    // 살코기
    ctx.fillStyle = getVar('--meat');
    ctx.beginPath(); ctx.ellipse(cX-s*0.1, cY, s*0.3, s*0.22, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.45)'; ctx.lineWidth=2; ctx.stroke();

    // 뼈 막대
    ctx.strokeStyle = getVar('--meat-fat'); ctx.lineWidth = 5;
    ctx.beginPath(); ctx.moveTo(cX+s*0.05, cY); ctx.lineTo(cX+s*0.3, cY); ctx.stroke();

    // 뼈 끝 동글
    ctx.fillStyle = getVar('--meat-fat');
    ctx.beginPath(); ctx.arc(cX+s*0.28, cY, s*0.14, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(cX+s*0.38, cY, s*0.10, 0, Math.PI*2); ctx.fill();

    // 하이라이트
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.beginPath(); ctx.ellipse(cX-s*0.18, cY-3, s*0.10, s*0.07, -0.3, 0, Math.PI*2); ctx.fill();
  }

  // 강아지 몸통(보간 좌표 버전)
  function drawDogBodyAt(ix, iy){
    const r=cell*0.42, cx=ix+cell/2, cy=iy+cell/2;
    const g=ctx.createRadialGradient(cx, cy, r*0.35, cx, cy, r);
    g.addColorStop(0, getVar('--dog-head')); g.addColorStop(1, getVar('--dog-body'));
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle=getVar('--dog-outline'); ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();

    // 털 광택 점
    ctx.fillStyle='rgba(255,255,255,0.08)';
    ctx.beginPath(); ctx.arc(cx+2, cy-2, 2, 0, Math.PI*2); ctx.fill();
  }

  // 강아지 머리(보간 좌표 버전)
  function drawDogHeadAt(ix, iy, dirNow){
    const r=cell*0.46;
    const cx=ix+cell/2, cy=iy+cell/2;

    // 머리
    const g=ctx.createRadialGradient(cx-2*dirNow.x, cy-2*dirNow.y, r*0.35, cx, cy, r);
    g.addColorStop(0, getVar('--dog-head')); g.addColorStop(1, getVar('--dog-body'));
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle=getVar('--dog-outline'); ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();

    // 귀
    const earOffset = 6, earBack = 6;
    drawEar(cx - dirNow.x*earBack + (-dirNow.y)*earOffset,
            cy - dirNow.y*earBack + ( dirNow.x)*earOffset, dirNow, true);
    drawEar(cx - dirNow.x*earBack + ( dirNow.y)*earOffset,
            cy - dirNow.y*earBack + (-dirNow.x)*earOffset, dirNow, false);

    // 눈
    const eyeOffset = 6, eyeSide = 7;
    const ex1 = cx + (-dirNow.y)*eyeSide + dirNow.x*eyeOffset;
    const ey1 = cy + ( dirNow.x)*eyeSide + dirNow.y*eyeOffset;
    const ex2 = cx + ( dirNow.y)*eyeSide + dirNow.x*eyeOffset;
    const ey2 = cy + (-dirNow.x)*eyeSide + dirNow.y*eyeOffset;
    ctx.fillStyle='white';
    ctx.beginPath(); ctx.arc(ex1,ey1,4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(ex2,ey2,4,0,Math.PI*2); ctx.fill();
    // 동공
    const pupilShift = 1.8;
    ctx.fillStyle='#0b1220';
    ctx.beginPath(); ctx.arc(ex1+dirNow.x*pupilShift, ey1+dirNow.y*pupilShift, 2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(ex2+dirNow.x*pupilShift, ey2+dirNow.y*pupilShift, 2, 0, Math.PI*2); ctx.fill();

    // 코
    const nx = cx + dirNow.x*(r*0.55), ny = cy + dirNow.y*(r*0.55);
    ctx.fillStyle='#111827';
    ctx.beginPath(); ctx.arc(nx, ny, 3, 0, Math.PI*2); ctx.fill();

    // 혀 (간헐적)
    const showTongue = (Math.floor(tongueTimer*5)%5===0);
    if(showTongue){
      const tx = cx + dirNow.x*(r+2), ty = cy + dirNow.y*(r+2);
      ctx.strokeStyle=getVar('--tongue'); ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(tx,ty); ctx.lineTo(tx+dirNow.x*7, ty+dirNow.y*7); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(tx+dirNow.x*7, ty+dirNow.y*7);
      ctx.lineTo(tx+dirNow.x*9 + (dirNow.y*2), ty+dirNow.y*9 + (-dirNow.x*2));
      ctx.moveTo(tx+dirNow.x*7, ty+dirNow.y*7);
      ctx.lineTo(tx+dirNow.x*9 + (-dirNow.y*2), ty+dirNow.y*9 + ( dirNow.x*2));
      ctx.stroke();
    }
  }

  function drawEar(x, y, dirNow, left){
    ctx.fillStyle=getVar('--dog-body');
    ctx.strokeStyle=getVar('--dog-outline');
    ctx.lineWidth=2;
    ctx.beginPath();
    const s=6;
    ctx.moveTo(x, y);
    ctx.lineTo(x - dirNow.x*2 + ( left? -dirNow.y : dirNow.y)*s, y - dirNow.y*2 + ( left?  dirNow.x : -dirNow.x)*s);
    ctx.lineTo(x - dirNow.x*2 + ( left?  dirNow.y : -dirNow.y)*s, y - dirNow.y*2 + ( left? -dirNow.x :  dirNow.x)*s);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  }

  function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  // ===== 컨트롤 =====
  function toggle(){ running=!running; toggleBtn.textContent=running?'일시정지':'시작';
    if(running){ audio(); lastTime=performance.now(); requestAnimationFrame(loop); } }
  function gameOver(){
    running=false; toggleBtn.textContent='시작';
    best=Math.max(best,score); localStorage.setItem(bestKey,best); bestEl.textContent=best;
    alert(`게임 오버! 점수: ${score}`);
  }
  toggleBtn.addEventListener('click',toggle);
  restartBtn.addEventListener('click',()=>init());

  // 키보드 R로 다시하기
  // (keydown에서 r 처리 → restartBtn.click())

  init();

  // ===== 9색 팔레트 셀렉터 =====
  const PRESETS = [
    {name:'흰', hex:'#ffffff'},
    {name:'검', hex:'#000000'},
    {name:'빨', hex:'#ff0000'},
    {name:'주', hex:'#ff7f00'},
    {name:'노', hex:'#ffff00'},
    {name:'초', hex:'#00ff00'},
    {name:'파', hex:'#0000ff'},
    {name:'남', hex:'#000080'},
    {name:'보', hex:'#800080'}
  ];
  const selA = document.getElementById('selA');
  const selB = document.getElementById('selB');
  const resetBtn = document.getElementById('resetColors');

  function fillSelect(sel, currentHex){
    sel.innerHTML='';
    PRESETS.forEach(p=>{
      const opt=document.createElement('option');
      opt.value=p.hex; opt.textContent=`${p.name} (${p.hex})`;
      if ((currentHex||'').toLowerCase()===p.hex.toLowerCase()) opt.selected=true;
      sel.appendChild(opt);
    });
  }
  function currentHex(varName, fallback){
    const v=getVar(varName);
    if(/^#/.test(v)) return v;
    const m=v.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if(!m) return fallback;
    const r=Number(m[1]).toString(16).padStart(2,'0');
    const g=Number(m[2]).toString(16).padStart(2,'0');
    const b=Number(m[3]).toString(16).padStart(2,'0');
    return `#${r}${g}${b}`;
  }
  // 초기 옵션 구성
  fillSelect(selA, currentHex('--tileA', '#223049'));
  fillSelect(selB, currentHex('--tileB', '#1a2438'));

  selA.addEventListener('change', e=>{
    document.documentElement.style.setProperty('--tileA', e.target.value);
    draw(0);
  });
  selB.addEventListener('change', e=>{
    document.documentElement.style.setProperty('--tileB', e.target.value);
    draw(0);
  });
  resetBtn.addEventListener('click', ()=>{
    document.documentElement.style.setProperty('--tileA', '#223049');
    document.documentElement.style.setProperty('--tileB', '#1a2438');
    fillSelect(selA, '#223049');
    fillSelect(selB, '#1a2438');
    draw(0);
  });
})();
</script>
</body>
</html>
